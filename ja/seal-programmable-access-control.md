[Seal: 実世界のアプリケーションのためのプログラマブルなアクセス制御](https://blog.sui.io/seal-programmable-access-control/)

## Seal: 実世界のアプリケーションのためのプログラマブルなアクセス制御

Seal は、プロダクトが最も重要な場所、つまりデータの境界でアクセスを制御することを可能にします。

![Seal: Programmable Access Control for Real-World Apps](https://blog.sui.io/content/images/size/w2000/2025/11/3_Blog-Header_Seal-Access-Control--1-.png)

ほとんどのアクセスシステムは、プロダクトが実際にどのように機能するかを考慮して構築されていません。従来の Web2 Cloud Identity and Access Management (IAM) ツールは、インフラストラクチャを中心に設計されており、誰がどの API を呼び出せるかを制御するものであり、アクセスがデータ、コンテキスト、タイミングに依存するプロダクトやユーザーに焦点を当てていません。

このギャップを埋めるために、チームはしばしばサードパーティのプロダクトやカスタムレイヤーを使用して、Role-Based Access Control（[RBAC](https://en.wikipedia.org/wiki/Role-based_access_control?ref=blog.sui.io)）や Attribute-Based Access Control（[ABAC](https://en.wikipedia.org/wiki/Attribute-based_access_control?ref=blog.sui.io)）レイヤーを追加しますが、これによりアーキテクチャがより複雑で脆弱になります。

[**Seal**](https://seal.mystenlabs.com/?ref=blog.sui.io) **は異なるアプローチを取ります**。暗号化をゲートとし、ポリシーを鍵とします。データはデフォルトで暗号化されたままであり、プログラマブルなアクセスポリシーが明示的に許可した場合にのみ復号化されます。ルールがデータ自体と共に存在するため、複数の外部システムをつなぎ合わせることなく、同じアプリの異なる部分に異なるルールを適用するなど、アプリケーションレベルのルールをクリーンに表現できます。

## プログラマブルなアクセスが外付け IAM を凌駕する理由

Cloud IAM は、「このプリンシパル ID はこのエンドポイントを呼び出せるか？」といったインフラストラクチャの問題を解決します。しかし、ほとんどのプロダクトは、「誰がこの Object を、この条件下で、この瞬間に開くことができるか」といったビジネスレベルのルールを必要とします。Seal では、このロジックをデータと共に移動するポリシーコードとして記述します。暗号化されたテキストは、サービス、クラウド、ストレージバックエンド間で移動できますが、ポリシーが承認した場合にのみ復号化されます。**これにより、デフォルトで選択的開示が可能になります**。

このモデルは拡散を減らします。ゲートウェイ、マイクロサービス、データベース間でロール、スコープ、権限リストを複製する代わりに、データの境界でルールを一度エンコードします。ポリシーのステートは [Sui](https://sui.io/?ref=blog.sui.io) に固定され、アクセスログのオプションのストレージは [Walrus](https://walrus.xyz/?ref=blog.sui.io) に保存されるため、散在するサーバーログよりも明確で、耐久性があり、監査可能な証跡が得られます。その結果、より簡単な運用、シークレットが漏洩する可能性のある場所の削減、そしてネットワークや API の配管ではなく、サブスクリプション、エンバーゴ、ライセンス条件などの機能に直接マッピングされるポリシーが実現します。

## 実際に使えるポリシー

Seal には、1 つのプロダクト内で組み合わせて使用できる[再利用可能なパターン](https://seal-docs.wal.app/ExamplePatterns/?ref=blog.sui.io)が付属しています。以下の例は、これらのルールを Sui Smart Contract でどのようにエンコードできるかを示しています。

* **許可リストまたはメンバーシップ** - 定義されたユーザーグループや AI エージェントと暗号化されたコンテンツを共有します。
  * Sui ポリシーの例：「Gold ティアのメンバーは *gold/* でタグ付けされたドキュメントを開くことができます。」
* **時間ロックされたアクセス** - アセットドロップやオークションのための公開をコーディネートします。
  * Sui ポリシーの例：「*2025-11-01T00:00Z* 以降に復号化します。ただし、法的保留がアクティブでない場合に限ります。」
* **サブスクリプションとライセンシング** - プレミアムコンテンツや API 結果への期限付き、有料アクセス。
  * Sui ポリシーの例：「アクティブなサブスクリプション AND リージョン = EU AND ライセンススコープに *model.infer* が含まれている。」
* **オーナープライベートデータ** - 現在の所有者のみが開くことができるポータブルな暗号化された Object。
  * Sui ポリシーの例：「現在の NFT 保有者のみが添付された特典を復号化できます。」
* **セキュアな投票または集計** - 条件が満たされるまで投票用紙を暗号化したままにし、その後、オンチェーンで検証可能な集計を生成します。
  * Sui ポリシーの例：「定足数 ≥ 60% AND 投票期間が終了している場合に結果を復号化します。」
* **事前署名スタイルのウィンドウ** - 特定の Walrus blob への期限付き、ベアラースタイルのアクセス。
  * Sui ポリシーの例：「*link.expiry* まで、この blob の復号化を許可します。」

### 実世界の例

これらのポリシーパターンは、さまざまな業種で使用できます。

* **エンタープライズデータルーム** - 「カウンターパーティが NDA に署名済み AND 取引フェーズ ≥ *DD* の場合、\*/dataroom/acme/\* のデータセットをロック解除します。規制当局は監査ログのみを閲覧できます。」
* **AI とデータライセンシング** - 「クライアントが SKU X の *dataset.read* を保持している場合、09:00-17:00 UTC にモデル Y での推論を許可します。生のトレーニングデータのエクスポートは拒否します。」
* **メディアとクリエイタープラットフォーム** - 「サブスクライバーは 30 日間ビデオをストリーミングできます。非サブスクライバーは 30 秒のプレビューを復号化できます。」
* **デジタルマーケティング** - 「キャンペーンアナリストはデフォルトで集計されたコホートメトリクスを復号化できます。個人レベルのデータは、有効なユーザー同意トークンが存在し、期限が切れていない場合を除き、シールされたままです。」
* **フィンテック** - 「監査者ロールは、レビュー期間中に報告されたケースの編集されたデータを復号化できます。PII フィールドは、リスク管理の承認が添付されるまで非表示のままです。」

メンバーシップでゲートされたコンテンツ、時間ロックされたプレビュー、ユーザーごとのプライベートノートなど、同じアプリの異なる機能に異なるポリシーを適用できます。これらはすべて、アドホックなアクセス制御リストの混乱なしに実現できます。

## これが従来の IAM よりもシンプルな理由

ほとんどのチームは、API のために Cloud IAM から始め、ID プロバイダーと統合し、オプションで RBAC のためにサードパーティシステムを追加し、その後、プロダクトロジックを反映するために独自のルールエンジンを構築します。各レイヤーは異なる言語（ロール、スコープ、条件）を話し、どれもデータ自体には添付されていません。結果として、ルールが重複し、マイクロサービス間でシークレットが漏洩し、誰が何にアクセスできたかを証明するためにログに依存することになります。

Seal では、実行ポイントがデータの境界にあります。ポリシーが別段の指示をするまで、データは暗号化されたままです。ポリシーは制御および監査可能なコードであり、承認は Walrus に記録できます。ゲートウェイ、サービス、ストレージシステム間で認可を散在させる必要がなくなります。3 つの重複するコントロールプレーンを維持する代わりに、ビジネスルールをプロダクトロジックの隣に一度エンコードし、暗号化に重い仕事を任せます。これにより、可動部品が減り、ミスの影響範囲が縮小し、ステークホルダーに明確なルールが提供されます。「ポリシーが承認しなかった場合、データは復号化されませんでした。」

## 実際にどのように機能するか

高レベルでは、Seal でデータを暗号化してプレーンテキストがデフォルトで公開されないようにし、ビジネスルールを小さく監査可能なポリシープログラムとしてキャプチャします。復号化には、ポリシーを評価する独立したキーサーバー（および近い将来、マルチパーティ計算委員会）からの閾値承認が必要であり、成功した場合にのみ、クライアントまたは許可されたバックエンドがデータを復号化するためのキーを受け取ります。

開発者は、SDK と適応しやすい Sui ベースのポリシーパターンを使用して、これを迅速に実装できます。Walrus およびオプションで [Nautilus](https://sui.io/nautilus?ref=blog.sui.io) と共に新しいアプリで Seal を使用するか、既存のアーキテクチャに適合させて、散在する認可の接着剤を簡潔で検証可能なポリシーコードに置き換えることができます。

## 試してみる

プレミアムコンテンツ、データセット、またはメッセージの添付ファイルを含む 1 つの機密フローを選び、シンプルなポリシー（メンバーシップまたは時間ロックが最初のステップとして適しています）の背後で Seal で保護してください。暗号化されたテキストを、Walrus など、すでにコンテンツを保存している場所に保存します。自信がついたら、サブスクリプション、ライセンシング、機能ごとのルールにアプローチを拡張し、段階的にプロダクトの異なる部分に異なるポリシーを適用します。[入門ガイド](https://seal-docs.wal.app/GettingStarted/?ref=blog.sui.io)をご覧ください。

Seal は、ビジネスレベルのアクセスをデータのあるべき場所に配置するため、デフォルトでプライベートで、推論しやすく、実世界の義務に対応できるプロダクトを構築できます。
